import json
import requests
import datetime
import time
import random
import os

class ultraChatBot():    
    def __init__(self, json):
        self.json = json
        self.dict_messages = json['data']
        self.ultraAPIUrl = 'https://api.ultramsg.com/instance114147/'
        self.token = 'e9gigjx981vwnnzh'
        
        # SOLUTION PERSISTANCE : Fichier pour sauvegarder les sessions
        self.sessions_file = 'user_sessions.json'
        self.user_sessions = self.load_sessions()
        
        # NOUVEAU : Syst√®me de d√©duplication des messages
        self.processed_messages_file = 'processed_messages.json'
        self.processed_messages = self.load_processed_messages()
        
        # Messages anti-spam pour utilisateurs normaux
        self.anti_spam_messages = [
            "Merci de patienter üôè Votre demande est en cours de traitement.",
            "Plus vous envoyez de messages, plus le temps de traitement est rallong√©.",
            "Pas d'inqui√©tude, vous √™tes bien pris en charge.",
            "Nous traitons les demandes par ordre d'arriv√©e.",
            "Veuillez patienter, nous analysons votre demande.",
            "Merci pour votre patience, nous vous r√©pondons au plus vite.",
            "Votre demande est importante pour nous, merci de patienter.",
            "Nous prenons en compte votre message, merci de ne pas spammer.",
            "Patience svp, notre √©quipe traite votre demande.",
            "Merci d'√©viter les messages r√©p√©t√©s, nous vous traitons."
        ]
        
        # Messages anti-spam pour utilisateurs transf√©r√©s (apr√®s 5+ messages)
        self.transferred_spam_messages = [
            "Plus vous envoyez de messages, plus le d√©lai de traitement sera rallong√©. ‚è≥ Merci de patienter.",
            "Votre demande est prise en charge, merci de patienter sans insister. üôè Nous allons r√©gler votre probl√®me.",
            "Chaque message suppl√©mentaire retarde le traitement de votre dossier. Patience svp.",
            "Notre √©quipe vous contactera, inutile d'envoyer plus de messages. Nous r√©glons votre probl√®me.",
            "Patience svp, votre insistance rallonge les d√©lais de r√©ponse. Nous vous aiderons."
        ]

    def load_processed_messages(self):
        """Charge la liste des messages d√©j√† trait√©s"""
        try:
            if os.path.exists(self.processed_messages_file):
                with open(self.processed_messages_file, 'r', encoding='utf-8') as f:
                    messages = json.load(f)
                    # Nettoyer les anciens messages (plus de 24h)
                    current_time = time.time()
                    cleaned = {k: v for k, v in messages.items() if current_time - v < 86400}
                    if len(cleaned) != len(messages):
                        self.save_processed_messages(cleaned)
                    return cleaned
            return {}
        except Exception as e:
            print(f"‚ùå Erreur chargement messages trait√©s: {e}")
            return {}

    def save_processed_messages(self, messages=None):
        """Sauvegarde la liste des messages trait√©s"""
        try:
            if messages is None:
                messages = self.processed_messages
            with open(self.processed_messages_file, 'w', encoding='utf-8') as f:
                json.dump(messages, f)
        except Exception as e:
            print(f"‚ùå Erreur sauvegarde messages trait√©s: {e}")

    def is_message_already_processed(self, message):
        """V√©rifie si ce message a d√©j√† √©t√© trait√©"""
        message_id = message.get('id', '')
        if message_id and message_id in self.processed_messages:
            print(f"üîÑ Message d√©j√† trait√©: {message_id}")
            return True
        return False

    def mark_message_as_processed(self, message):
        """Marque un message comme trait√©"""
        message_id = message.get('id', '')
        if message_id:
            self.processed_messages[message_id] = time.time()
            self.save_processed_messages()
            print(f"‚úÖ Message marqu√© comme trait√©: {message_id}")

    def load_sessions(self):
        """Charge les sessions depuis le fichier JSON"""
        try:
            if os.path.exists(self.sessions_file):
                with open(self.sessions_file, 'r', encoding='utf-8') as f:
                    sessions = json.load(f)
                    print(f"‚úÖ Sessions charg√©es: {len(sessions)} utilisateurs")
                    return sessions
            else:
                print("üìù Nouveau fichier de sessions cr√©√©")
                return {}
        except Exception as e:
            print(f"‚ùå Erreur chargement sessions: {e}")
            return {}
        """Charge les sessions depuis le fichier JSON"""
        try:
            if os.path.exists(self.sessions_file):
                with open(self.sessions_file, 'r', encoding='utf-8') as f:
                    sessions = json.load(f)
                    print(f"‚úÖ Sessions charg√©es: {len(sessions)} utilisateurs")
                    return sessions
            else:
                print("üìù Nouveau fichier de sessions cr√©√©")
                return {}
        except Exception as e:
            print(f"‚ùå Erreur chargement sessions: {e}")
            return {}

    def save_sessions(self):
        """Sauvegarde les sessions dans le fichier JSON"""
        try:
            with open(self.sessions_file, 'w', encoding='utf-8') as f:
                json.dump(self.user_sessions, f, ensure_ascii=False, indent=2)
            print(f"üíæ Sessions sauvegard√©es: {len(self.user_sessions)} utilisateurs")
        except Exception as e:
            print(f"‚ùå Erreur sauvegarde sessions: {e}")

    def send_requests(self, type, data):
        url = f"{self.ultraAPIUrl}{type}?token={self.token}"
        headers = {'Content-type': 'application/json'}
        answer = requests.post(url, data=json.dumps(data), headers=headers)
        return answer.json()

    def send_message(self, chatID, text):
        data = {"to": chatID, "body": text}  
        answer = self.send_requests('messages/chat', data)
        return answer

    def format_phone_number(self, whatsapp_id):
        """NOUVEAU: Formate le num√©ro WhatsApp pour le SAV"""
        # Supprimer @c.us et ajouter +
        if "@c.us" in whatsapp_id:
            clean_number = whatsapp_id.replace("@c.us", "")
            formatted_number = f"+{clean_number}"
            print(f"üì± Num√©ro format√©: {whatsapp_id} ‚Üí {formatted_number}")
            return formatted_number
        return whatsapp_id

    def send_to_sav(self, client_info, problem_type="general"):
        """Envoie une alerte au SAV WhatsApp (individuel ou groupe)"""
        # # OPTION 1: Envoyer √† un num√©ro individuel
        # sav_destination = "+221770184531@c.us"
        
        # OPTION 2: Envoyer √† un groupe WhatsApp (recommand√©)
        # Remplacez par l'ID de votre groupe SAV
        sav_destination = "120363366576958989@g.us"  # Format: 1234567890-1234567890@g.us
        
        # OPTION 3: Envoyer aux deux (groupe + responsable)
        # sav_destination = ["+221770184531@c.us", "VOTRE_GROUPE_SAV_ID@g.us"]
        client_phone_raw = client_info.get('phone', 'Inconnu')
        
        # NOUVEAU: Formater le num√©ro pour le SAV
        client_phone_formatted = self.format_phone_number(client_phone_raw)
        
        # Messages clairs pour le SAV
        if problem_type == "no_access":
            client_name = client_info.get('name', 'Non fourni')
            message = f"üö® CLIENT SANS ACCES\n\nNumero: {client_phone_formatted}\nNom: {client_name}\nProbleme: Commande payee mais acces non recu\nCapture: Re√ßue\n\n‚ö° A traiter rapidement SVP"
            
        elif problem_type == "technical":
            message = f"üîß PROBLEME TECHNIQUE\n\nNumero: {client_phone_formatted}\nProbleme: Dysfonctionnement signale\nCapture: Re√ßue\n\n‚ö° A resoudre rapidement SVP"
            
        elif problem_type == "conseiller_humain":
            message = f"üìû DEMANDE CONSEILLER\n\nNumero: {client_phone_formatted}\nDemande: Contact conseiller humain\n\n‚ö° A traiter rapidement SVP"
            
        else:
            message = f"‚ùì DEMANDE CLIENT\n\nNumero: {client_phone_formatted}\nType: {problem_type}\n\n‚ö° A traiter SVP"
        
        # NOUVEAU: Envoyer √† une ou plusieurs destinations
        if isinstance(sav_destination, list):
            # Envoyer √† plusieurs destinations
            results = []
            for destination in sav_destination:
                print(f"üì§ Envoi alerte SAV vers {destination}: {message}")
                result = self.send_message(destination, message)
                results.append(result)
            return results
        else:
            # Envoyer √† une seule destination
            print(f"üì§ Envoi alerte SAV vers {sav_destination}: {message}")
            return self.send_message(sav_destination, message)

    def get_main_menu(self):
        return """Bienvenue chez irabonnement.com üëã

Je suis l'assistant automatique con√ßu par DakarDev ü§ñ

Je suis encore en phase d'apprentissage, merci de votre compr√©hension üôè

Voici ce que je peux faire pour vous üëá :

1Ô∏è‚É£ Comment √ßa fonctionne ?
2Ô∏è‚É£ J'ai pass√© commande, je n'ai rien re√ßu
3Ô∏è‚É£ J'ai un probl√®me avec mon compte
4Ô∏è‚É£ Je veux me r√©abonner
5Ô∏è‚É£ Je veux acheter un abonnement
6Ô∏è‚É£ Contacter un conseiller humain"""

    def get_services_selection(self):
        return """Parfait üòä

Quel produit souhaitez-vous comprendre ? R√©pondez simplement avec le nom du produit parmi cette liste :

- Netflix
- Prime Video
- Disney+
- Crunchyroll
- IPTV
- Surfshark VPN
- NordVPN
- Carte Xbox
- Carte PSN
- HBO Max"""

    def get_service_info(self, service):
        """Reconnaissance des noms de services"""
        service_lower = service.lower().strip()
        
        # Dictionnaire avec toutes les variantes possibles
        service_info = {
            "netflix": "üü• Netflix :\n\nüé¨ Netflix : √Ä partir de 2500F, vous cotisez pour un profil personnel, utilisable sur un seul appareil.\n\nUne fois votre commande pass√©e, vous recevez automatiquement vos acc√®s par mail et WhatsApp.",
            
            "prime video": "üü¶ Prime Video :\n\nüé• Prime Video : Service de streaming Amazon avec films et s√©ries exclusives.\n\nAcc√®s direct apr√®s commande, compatible tous appareils.",
            "prime": "üü¶ Prime Video :\n\nüé• Prime Video : Service de streaming Amazon avec films et s√©ries exclusives.\n\nAcc√®s direct apr√®s commande, compatible tous appareils.",
            
            "disney+": "üü¶ Disney+ :\n\nüé• Disney+ : Disponible uniquement via VPN.\n\nNous vous fournissons un compte Disney+ + un compte VPN.\n\n1Ô∏è‚É£ Connectez d'abord le VPN aux üá∫üá∏ USA (serveur Chicago)\n2Ô∏è‚É£ Ensuite, ouvrez l'application Disney+",
            "disney": "üü¶ Disney+ :\n\nüé• Disney+ : Disponible uniquement via VPN.\n\nNous vous fournissons un compte Disney+ + un compte VPN.\n\n1Ô∏è‚É£ Connectez d'abord le VPN aux üá∫üá∏ USA (serveur Chicago)\n2Ô∏è‚É£ Ensuite, ouvrez l'application Disney+",
            
            "crunchyroll": "üü† Crunchyroll :\n\nüéå Crunchyroll : La plateforme #1 pour les anim√©s et mangas.\n\nAcc√®s premium √† tous les contenus, sous-titres fran√ßais disponibles.",
            
            "iptv": "üü© IPTV :\n\nüì∫ IPTV : N√©cessite un VPN ou une configuration DNS.\n\nVoici les √©tapes :\n1Ô∏è‚É£ T√©l√©chargez une app OTT (ex : Smarters Player, Televizo, 9Xtream, Hot IPTV)\n2Ô∏è‚É£ Connectez un VPN (comme Surfshark) ou utilisez les DNS fournis apr√®s l'achat.",
            
            "surfshark vpn": "üîí Surfshark VPN :\n\nüõ°Ô∏è VPN premium pour s√©curiser votre connexion et acc√©der aux contenus g√©o-bloqu√©s.\n\nCompatible tous appareils, configuration simple.",
            "surfshark": "üîí Surfshark VPN :\n\nüõ°Ô∏è VPN premium pour s√©curiser votre connexion et acc√©der aux contenus g√©o-bloqu√©s.\n\nCompatible tous appareils, configuration simple.",
            
            "nordvpn": "üîµ NordVPN :\n\nüõ°Ô∏è VPN haut de gamme pour protection et acc√®s mondial.\n\nServeurs ultra-rapides, s√©curit√© maximale.",
            "nord vpn": "üîµ NordVPN :\n\nüõ°Ô∏è VPN haut de gamme pour protection et acc√®s mondial.\n\nServeurs ultra-rapides, s√©curit√© maximale.",
            "nord": "üîµ NordVPN :\n\nüõ°Ô∏è VPN haut de gamme pour protection et acc√®s mondial.\n\nServeurs ultra-rapides, s√©curit√© maximale.",
            
            "carte xbox": "üü¢ Carte Xbox :\n\nüéÆ Cartes cadeaux Xbox pour acheter jeux et contenus.\n\nLivraison imm√©diate du code de la carte.",
            "xbox": "üü¢ Carte Xbox :\n\nüéÆ Cartes cadeaux Xbox pour acheter jeux et contenus.\n\nLivraison imm√©diate du code de la carte.",
            
            "carte psn": "üîµ Carte PSN :\n\nüéÆ Cartes PlayStation Network pour le PlayStation Store.\n\nCodes livr√©s instantan√©ment apr√®s achat.",
            "psn": "üîµ Carte PSN :\n\nüéÆ Cartes PlayStation Network pour le PlayStation Store.\n\nCodes livr√©s instantan√©ment apr√®s achat.",
            
            "hbo max": "üü£ HBO Max :\n\nüé≠ HBO Max : S√©ries et films premium, contenu exclusif.\n\nAcc√®s complet √† la biblioth√®que HBO.",
            "hbo": "üü£ HBO Max :\n\nüé≠ HBO Max : S√©ries et films premium, contenu exclusif.\n\nAcc√®s complet √† la biblioth√®que HBO."
        }
        
        # Recherche exacte d'abord
        if service_lower in service_info:
            return service_info[service_lower]
        
        # Recherche partielle si pas trouv√©
        for key, value in service_info.items():
            if service_lower in key or key in service_lower:
                return value
        
        return "‚ùå Service non trouv√©. Veuillez taper exactement un nom de la liste."

    def handle_no_access_request(self, chatID):
        return """D'accord, nous allons vous aider ‚úÖ

Veuillez d'abord nous envoyer votre **nom et pr√©nom** utilis√©s lors de la commande.

Ensuite, nous vous demanderons la capture d'√©cran de votre paiement."""

    def handle_technical_problem(self, chatID):
        return """D√©sol√© pour le d√©sagr√©ment üò•

Pour mieux comprendre votre probl√®me, merci de nous envoyer une **capture d'√©cran** du message ou de l'erreur rencontr√©e.

Une fois re√ßu, nous le transmettrons au service technique."""

    def handle_bug_solutions(self, chatID):
        return """D√©sol√© pour cela üò•

Voici quelques v√©rifications de base :

1Ô∏è‚É£ D√©sinstallez puis r√©installez l'application
2Ô∏è‚É£ Red√©marrez votre appareil  
3Ô∏è‚É£ Assurez-vous d'avoir activ√© le VPN si n√©cessaire

üëâ Si cela ne fonctionne toujours pas, merci de nous envoyer une **capture d'√©cran** de l'erreur.

Nous transmettrons √† notre service technique."""

    def handle_resubscription(self, chatID):
        return """Merci de vous rendre sur notre site : https://irabonnement.com

üëâ Si votre abonnement est expir√©, vous devrez commander un **nouveau compte**."""

    def handle_new_purchase(self, chatID):
        return """Parfait ‚úÖ

Vous pouvez commander directement sur : https://irabonnement.com

La livraison est automatique üì©"""

    def handle_human_advisor(self, chatID):
        # Transmettre au SAV
        self.send_to_sav({"phone": chatID}, "conseiller_humain")
        
        return """Votre demande a √©t√© transmise √† notre service client.

‚è≥ Un conseiller va vous r√©pondre dans un d√©lai estim√© de **moins de 40 minutes** (entre 10h et 22h).

Merci pour votre patience."""

    def is_in_active_flow(self, chatID):
        """NOUVEAU: V√©rifie si l'utilisateur est dans un flux actif (pour √©viter le spam)"""
        state = self.get_user_state(chatID)
        active_states = ["waiting_name", "waiting_payment_screenshot", "waiting_screenshot", "services_selection"]
        return state in active_states

    def check_spam(self, chatID):
        """CORRECTION FINALE: Spam check qui fonctionne vraiment"""
        current_time = time.time()
        
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"messages": [], "state": "menu", "data": {}}
        
        current_state = self.get_user_state(chatID)
        
        # IMPORTANT: Si utilisateur dans un flux actif, PAS de spam check
        if self.is_in_active_flow(chatID):
            print(f"üîÑ Utilisateur {chatID} dans flux actif - pas de spam check")
            return False
        
        # CORRECTION: Toujours ajouter le message actuel AVANT le nettoyage
        self.user_sessions[chatID]["messages"].append(current_time)
        
        # Si utilisateur transf√©r√© : spam apr√®s 3+ messages en 2 minutes
        if current_state in ["transferred_to_sav", "transferred_to_human"]:
            # Nettoyer les anciens messages (plus de 120 secondes = 2 minutes)
            self.user_sessions[chatID]["messages"] = [
                msg_time for msg_time in self.user_sessions[chatID]["messages"] 
                if current_time - msg_time < 120
            ]
            
            message_count = len(self.user_sessions[chatID]["messages"])
            print(f"üîç Spam check transf√©r√© - Messages: {message_count}")
            
            # CORRECTION: Sauvegarder apr√®s modification
            self.save_sessions()
            
            if message_count >= 6:
                return "transferred_total_silence"  # Silence total apr√®s 6+ messages
            elif message_count >= 3:
                return "transferred_spam"  # Message anti-spam apr√®s 3+ messages
            else:
                return "transferred_silent"  # Silence simple < 3 messages
        
        # Utilisateur normal : spam = 3+ messages en 90 secondes
        else:
            # Nettoyer les anciens messages (plus de 90 secondes)
            self.user_sessions[chatID]["messages"] = [
                msg_time for msg_time in self.user_sessions[chatID]["messages"] 
                if current_time - msg_time < 90
            ]
            
            message_count = len(self.user_sessions[chatID]["messages"])
            print(f"üîç Spam check normal - Messages: {message_count}")
            
            # CORRECTION: Sauvegarder apr√®s modification
            self.save_sessions()
            
            if message_count >= 3:
                return "normal_spam"
        
        return False

    def get_user_state(self, chatID):
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"state": "menu", "messages": [], "data": {}}
        return self.user_sessions[chatID]["state"]

    def set_user_state(self, chatID, state):
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"messages": [], "data": {}}
        self.user_sessions[chatID]["state"] = state
        print(f"üîÑ √âtat chang√© pour {chatID}: {state}")
        self.save_sessions()

    def get_user_data(self, chatID, key, default=None):
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"state": "menu", "messages": [], "data": {}}
        return self.user_sessions[chatID]["data"].get(key, default)

    def set_user_data(self, chatID, key, value):
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"state": "menu", "messages": [], "data": {}}
        self.user_sessions[chatID]["data"][key] = value
        self.save_sessions()

    def is_image_message(self, message):
        """D√©tecte si le message est une image"""
        return message.get('type') == 'image'

    def ProcessingŸÄincomingŸÄmessages(self):
        if self.dict_messages != []:
            message = self.dict_messages
            
            # NOUVEAU : V√©rification de d√©duplication
            if self.is_message_already_processed(message):
                return 'AlreadyProcessed'
            
            # Marquer le message comme trait√© imm√©diatement
            self.mark_message_as_processed(message)
            
            # V√©rifier les images au lieu de "message vide"
            if self.is_image_message(message):
                print(f"üì∏ Image re√ßue de {message['from']}")
                chatID = message['from']
                message_body = "[IMAGE]"
                message_lower = "image"
            elif not message.get('body'):
                print("Message vide re√ßu (pas une image)")
                return 'EmptyMessage'
            else:
                chatID = message['from']
                message_body = message['body'].strip()
                message_lower = message_body.lower()
            
            # V√©rifier que ce n'est pas un message envoy√© par nous
            if message['fromMe']:
                print("Message envoy√© par nous, ignor√©")
                return 'FromMe'
                
            print(f"üì± Message re√ßu de {chatID}: {message_body}")
            print(f"üîÑ √âtat actuel: {self.get_user_state(chatID)}")
            
            # === PRIORIT√â ABSOLUE #1 : COMMANDES DE RETOUR AU MENU ===
            if message_lower in ['menu', 'accueil', 'retour', 'retourner au menu']:
                print(f"üîÑ RETOUR AU MENU FORC√â")
                self.set_user_state(chatID, "menu")
                # Nettoyer les messages pour √©viter le spam check
                if chatID in self.user_sessions:
                    self.user_sessions[chatID]["messages"] = []
                return self.send_message(chatID, self.get_main_menu())
            
            # === PRIORIT√â #2 : GESTION DU SPAM (apr√®s menu) ===
            current_state = self.get_user_state(chatID)
            spam_status = self.check_spam(chatID)
            
            if spam_status == "transferred_total_silence":
                print(f"üîá Utilisateur {chatID} transf√©r√© - silence total (8+ messages)")
                return "TransferredTotalSilence"
                
            elif spam_status == "transferred_spam":
                response = random.choice(self.transferred_spam_messages)
                print(f"‚ö†Ô∏è Utilisateur {chatID} transf√©r√© - message anti-spam")
                return self.send_message(chatID, response)
                
            elif spam_status == "transferred_silent":
                print(f"üîá Utilisateur {chatID} transf√©r√© - silence simple")
                return "TransferredSilent"
                
            elif spam_status == "normal_spam":
                spam_response = random.choice(self.anti_spam_messages)
                print(f"‚ö†Ô∏è Utilisateur {chatID} normal - anti-spam")
                return self.send_message(chatID, spam_response)
            
            # === PRIORIT√â #3 : SALUTATIONS ET MESSAGES SP√âCIAUX ===
            if current_state == "menu":
                # Gestion des salutations
                if any(word in message_lower for word in ['bonjour', 'bonsoir', 'salut', 'hello', 'hi']):
                    print(f"üëã Salutation d√©tect√©e: {message_lower}")
                    return self.send_message(chatID, self.get_main_menu())
                
                # Messages sp√©cifiques du site
                if "je vous contacte depuis le site irabonnement" in message_lower:
                    print(f"üåê Message site d√©tect√©")
                    return self.send_message(chatID, self.get_main_menu())
                    
                if "j'ai une question" in message_lower:
                    print(f"‚ùì Question g√©n√©rique d√©tect√©e")
                    return self.send_message(chatID, self.get_main_menu())
            
            # === PRIORIT√â #4 : POLITESSE (sauf si transf√©r√©) ===
            if current_state not in ["transferred_to_sav", "transferred_to_human"]:
                if message_lower in ['merci', 'thank you', 'thanks']:
                    return self.send_message(chatID, "Je vous en prie üòä")
            
            # === PRIORIT√â #5 : GESTION DES BUGS (sauf si transf√©r√©) ===
            if current_state not in ["transferred_to_sav", "transferred_to_human"]:
                if any(word in message_lower for word in ['√ßa marche pas', 'marche pas', 'bug', 'ne fonctionne pas', 'probl√®me connexion', 'je n\'arrive pas', 'pas connecter']):
                    self.set_user_state(chatID, "menu")
                    return self.send_message(chatID, self.handle_bug_solutions(chatID))
            
            # === NAVIGATION SELON L'√âTAT ===
            if current_state == "menu":
                print(f"üè† Traitement menu pour: {message_lower}")
                
                # CORRECTION: Gestion des images non sollicit√©es en √©tat menu
                if message_lower == "image":
                    return self.send_message(chatID, "Je n'ai pas besoin d'image pour le moment. üòä\n\nVeuillez choisir une option du menu en tapant le num√©ro (1, 2, 3, 4, 5 ou 6).")
                
                if message_lower == "1" or "comment √ßa fonctionne" in message_lower:
                    self.set_user_state(chatID, "services_selection")
                    return self.send_message(chatID, self.get_services_selection())
                    
                elif message_lower == "2" or "j'ai pass√© commande" in message_lower or "rien re√ßu" in message_lower:
                    self.set_user_state(chatID, "waiting_name")
                    return self.send_message(chatID, self.handle_no_access_request(chatID))
                    
                elif message_lower == "3" or "probl√®me avec mon compte" in message_lower:
                    self.set_user_state(chatID, "waiting_screenshot")
                    return self.send_message(chatID, self.handle_technical_problem(chatID))
                    
                elif message_lower == "4" or "r√©abonner" in message_lower or "reabonner" in message_lower:
                    # CORRECTION: L'option 4 reste en √©tat menu et ne demande jamais d'image
                    return self.send_message(chatID, self.handle_resubscription(chatID))
                    
                elif message_lower == "5" or "acheter un abonnement" in message_lower or "nouvelle commande" in message_lower:
                    return self.send_message(chatID, self.handle_new_purchase(chatID))
                    
                elif message_lower == "6" or "conseiller humain" in message_lower or "agent" in message_lower:
                    self.set_user_state(chatID, "transferred_to_human")
                    return self.send_message(chatID, self.handle_human_advisor(chatID))
                    
            elif current_state == "services_selection":
                # L'utilisateur a choisi un service
                print(f"üéØ Recherche service pour: '{message_lower}'")
                service_info = self.get_service_info(message_lower)
                
                if "‚ùå Service non trouv√©" not in service_info:
                    print(f"‚úÖ Service trouv√©, envoi info")
                    self.set_user_state(chatID, "menu")
                    return self.send_message(chatID, service_info + "\n\nTapez 'menu' pour retourner au menu principal.")
                else:
                    print(f"‚ùå Service non trouv√©")
                    return self.send_message(chatID, "‚ùå Service non trouv√©. " + self.get_services_selection())
                
            elif current_state == "waiting_name":
                # CORRECTION MAJEURE OPTION 2 : L'utilisateur envoie son nom
                if message_lower == "image":
                    return self.send_message(chatID, "Merci pour l'image, mais nous avons d'abord besoin de votre **nom et pr√©nom** en texte.")
                
                print(f"üë§ Nom re√ßu: {message_body}")
                self.set_user_data(chatID, "customer_name", message_body)
                self.set_user_state(chatID, "waiting_payment_screenshot")
                
                return self.send_message(chatID, f"""Merci {message_body} ‚úÖ

Maintenant, veuillez envoyer la **capture d'√©cran de votre paiement**.

D√®s r√©ception, nous transmettrons le tout au service technique.""")
                
            elif current_state == "waiting_payment_screenshot":
                # CORRECTION MAJEURE OPTION 2 : L'utilisateur envoie la capture de paiement
                if message_lower != "image":
                    return self.send_message(chatID, "Nous attendons la **capture d'√©cran de votre paiement**. Veuillez envoyer l'image.")
                
                print(f"üí≥ Capture paiement re√ßue de: {chatID}")
                customer_name = self.get_user_data(chatID, "customer_name", "Non fourni")
                
                # Envoyer au SAV
                self.send_to_sav({
                    "phone": chatID,
                    "name": customer_name,
                    "payment_proof": "Capture de paiement re√ßue",
                    "type": "no_access"
                }, "no_access")
                
                self.set_user_state(chatID, "transferred_to_sav")
                response = f"""‚úÖ Parfait ! Nous avons bien re√ßu vos informations :

üë§ Nom : {customer_name}
üí≥ Capture de paiement : Re√ßue

üì§ Votre dossier a √©t√© transmis √† notre service technique.

‚è≥ Un agent va vous r√©pondre dans un d√©lai estim√© de moins de 40 minutes (entre 10h et 22h).

Merci pour votre patience."""
                return self.send_message(chatID, response)
                
            elif current_state == "waiting_screenshot":
                # CORRECTION OPTION 3 : L'utilisateur envoie une capture du probl√®me
                if message_lower != "image":
                    return self.send_message(chatID, "Nous attendons une **capture d'√©cran** de votre probl√®me. Veuillez envoyer l'image.")
                
                print(f"üì∏ Capture technique re√ßue de: {chatID}")
                
                # Envoyer au SAV avec num√©ro du client
                self.send_to_sav({
                    "phone": chatID,
                    "problem": "Capture d'√©cran du probl√®me re√ßue",
                    "type": "technical"
                }, "technical")
                
                self.set_user_state(chatID, "transferred_to_sav")
                response = """‚úÖ Merci ! Nous avons bien re√ßu votre capture d'√©cran.

üì§ Votre probl√®me a √©t√© transmis √† notre service technique.

‚è≥ Un agent vous r√©pondra sous peu (d√©lai moyen : moins de 40 minutes, entre 10h et 22h).

Nous allons r√©gler votre probl√®me rapidement."""
                return self.send_message(chatID, response)
                
            elif current_state == "transferred_to_sav" or current_state == "transferred_to_human":
                # L'utilisateur est d√©j√† transf√©r√© : silence (g√©r√© par le spam ci-dessus)
                print(f"üîá Utilisateur {chatID} transf√©r√© - trait√© par la gestion du spam")
                return "TransferredHandledBySpam"
            
            # === MESSAGE NON RECONNU (sauf si transf√©r√©) ===
            if current_state not in ["transferred_to_sav", "transferred_to_human"]:
                print(f"‚ùì Message non reconnu, retour au menu")
                self.set_user_state(chatID, "menu")
                return self.send_message(chatID, self.get_main_menu())
            
            # Si transf√©r√© et message non reconnu : d√©j√† g√©r√© par le spam
            return "TransferredSilent"
        
        return 'NoData'