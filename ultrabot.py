import json
import requests
import datetime
import time
import random
import os

class ultraChatBot():    
    def __init__(self, json):
        self.json = json
        self.dict_messages = json['data']
        self.ultraAPIUrl = 'https://api.ultramsg.com/instance114147/'
        self.token = 'e9gigjx981vwnnzh'
        
        # SOLUTION PERSISTANCE : Fichier pour sauvegarder les sessions
        self.sessions_file = 'user_sessions.json'
        self.user_sessions = self.load_sessions()
        
        # NOUVEAU : Syst√®me de d√©duplication des messages
        self.processed_messages_file = 'processed_messages.json'
        self.processed_messages = self.load_processed_messages()
        
        # Messages anti-spam pour utilisateurs normaux
        self.anti_spam_messages = [
            "Merci de patienter üôè Votre demande est en cours de traitement.",
            "Plus vous envoyez de messages, plus le temps de traitement est rallong√©.",
            "Pas d'inqui√©tude, vous √™tes bien pris en charge.",
            "Nous traitons les demandes par ordre d'arriv√©e.",
            "Veuillez patienter, nous analysons votre demande.",
            "Merci pour votre patience, nous vous r√©pondons au plus vite.",
            "Votre demande est importante pour nous, merci de patienter.",
            "Nous prenons en compte votre message, merci de ne pas spammer.",
            "Patience svp, notre √©quipe traite votre demande.",
            "Merci d'√©viter les messages r√©p√©t√©s, nous vous traitons."
        ]
        
        # Messages anti-spam pour utilisateurs transf√©r√©s
        self.transferred_spam_messages = [
            "Plus vous envoyez de messages, plus le d√©lai de traitement sera rallong√©. ‚è≥ Merci de patienter.",
            "Votre demande est prise en charge, merci de patienter sans insister. üôè Nous allons r√©gler votre probl√®me.",
            "Chaque message suppl√©mentaire retarde le traitement de votre dossier. Patience svp.",
            "Notre √©quipe vous contactera, inutile d'envoyer plus de messages. Nous r√©glons votre probl√®me.",
            "Patience svp, votre insistance rallonge les d√©lais de r√©ponse. Nous vous aiderons."
        ]

        # NOUVEAU : Messages d'avertissement menu
        self.menu_warning_messages = {
            "first": "Veuillez r√©pondre √† partir du menu que je vous affiche. Tapez simplement le num√©ro de votre choix (1, 2, 3, 4, 5 ou 6). Toute autre r√©ponse ne peut pas √™tre comprise par mon syst√®me automatique.",
            "second": "N'exag√©rez pas, merci de r√©pondre √† partir du menu en tapant le num√©ro correspondant √† votre demande. C'est la seule fa√ßon pour moi de vous aider efficacement.",
            "final": "Ok, comme vous voulez. Si vous ne souhaitez pas coop√©rer, je reste en silence. Vous pourrez me reparler dans 2 heures ou taper 'menu' √† tout moment."
        }

    def load_processed_messages(self):
        """Charge la liste des messages d√©j√† trait√©s"""
        try:
            if os.path.exists(self.processed_messages_file):
                with open(self.processed_messages_file, 'r', encoding='utf-8') as f:
                    messages = json.load(f)
                    # Nettoyer les anciens messages (plus de 24h)
                    current_time = time.time()
                    cleaned = {k: v for k, v in messages.items() if current_time - v < 86400}
                    if len(cleaned) != len(messages):
                        self.save_processed_messages(cleaned)
                    return cleaned
            return {}
        except Exception as e:
            print(f"‚ùå Erreur chargement messages trait√©s: {e}")
            return {}

    def save_processed_messages(self, messages=None):
        """Sauvegarde la liste des messages trait√©s"""
        try:
            if messages is None:
                messages = self.processed_messages
            with open(self.processed_messages_file, 'w', encoding='utf-8') as f:
                json.dump(messages, f)
        except Exception as e:
            print(f"‚ùå Erreur sauvegarde messages trait√©s: {e}")

    def is_message_already_processed(self, message):
        """V√©rifie si ce message a d√©j√† √©t√© trait√©"""
        message_id = message.get('id', '')
        if message_id and message_id in self.processed_messages:
            print(f"üîÑ Message d√©j√† trait√©: {message_id}")
            return True
        return False

    def mark_message_as_processed(self, message):
        """Marque un message comme trait√©"""
        message_id = message.get('id', '')
        if message_id:
            self.processed_messages[message_id] = time.time()
            self.save_processed_messages()
            print(f"‚úÖ Message marqu√© comme trait√©: {message_id}")

    def load_sessions(self):
        """Charge les sessions depuis le fichier JSON"""
        try:
            if os.path.exists(self.sessions_file):
                with open(self.sessions_file, 'r', encoding='utf-8') as f:
                    sessions = json.load(f)
                    print(f"‚úÖ Sessions charg√©es: {len(sessions)} utilisateurs")
                    return sessions
            else:
                print("üìù Nouveau fichier de sessions cr√©√©")
                return {}
        except Exception as e:
            print(f"‚ùå Erreur chargement sessions: {e}")
            return {}

    def save_sessions(self):
        """Sauvegarde les sessions dans le fichier JSON"""
        try:
            with open(self.sessions_file, 'w', encoding='utf-8') as f:
                json.dump(self.user_sessions, f, ensure_ascii=False, indent=2)
            print(f"üíæ Sessions sauvegard√©es: {len(self.user_sessions)} utilisateurs")
        except Exception as e:
            print(f"‚ùå Erreur sauvegarde sessions: {e}")

    def send_requests(self, type, data):
        url = f"{self.ultraAPIUrl}{type}?token={self.token}"
        headers = {'Content-type': 'application/json'}
        answer = requests.post(url, data=json.dumps(data), headers=headers)
        return answer.json()

    def send_message(self, chatID, text):
        data = {"to": chatID, "body": text}  
        answer = self.send_requests('messages/chat', data)
        return answer

    def format_phone_number(self, whatsapp_id):
        """Formate le num√©ro WhatsApp pour le SAV"""
        if "@c.us" in whatsapp_id:
            clean_number = whatsapp_id.replace("@c.us", "")
            formatted_number = f"+{clean_number}"
            print(f"üì± Num√©ro format√©: {whatsapp_id} ‚Üí {formatted_number}")
            return formatted_number
        return whatsapp_id

    def send_to_sav(self, client_info, problem_type="general"):
        """Envoie une alerte au SAV WhatsApp"""
        sav_destination = "120363366576958989@g.us"
        client_phone_raw = client_info.get('phone', 'Inconnu')
        client_phone_formatted = self.format_phone_number(client_phone_raw)
        
        # Messages clairs pour le SAV
        if problem_type == "no_access":
            client_name = client_info.get('name', 'Non fourni')
            message = f"üö® CLIENT SANS ACCES\n\nNumero: {client_phone_formatted}\nNom: {client_name}\nProbleme: Commande payee mais acces non recu\nCapture: Re√ßue\n\n‚ö° A traiter rapidement SVP"
            
        elif problem_type == "technical":
            message = f"üîß PROBLEME TECHNIQUE\n\nNumero: {client_phone_formatted}\nProbleme: Dysfonctionnement signale\nCapture: Re√ßue\n\n‚ö° A resoudre rapidement SVP"
            
        elif problem_type == "conseiller_humain":
            message = f"üìû DEMANDE CONSEILLER\n\nNumero: {client_phone_formatted}\nDemande: Contact conseiller humain\n\n‚ö° A traiter rapidement SVP"
            
        else:
            message = f"‚ùì DEMANDE CLIENT\n\nNumero: {client_phone_formatted}\nType: {problem_type}\n\n‚ö° A traiter SVP"
        
        print(f"üì§ Envoi alerte SAV vers {sav_destination}: {message}")
        return self.send_message(sav_destination, message)

    def check_sav_takeover(self, message):
        """NOUVEAU: D√©tecte si un membre SAV prend en charge"""
        sav_phrases = [
            "je suis la sav qui vous prends en charge",
            "je suis le sav qui vous prend en charge", 
            "sav qui vous prend en charge",
            "je m'occupe de votre dossier",
            "je prends votre demande en charge",
            "bonjour je suis votre conseiller"
        ]
        
        message_body = message.get('body', '').lower()
        for phrase in sav_phrases:
            if phrase in message_body:
                return True
        return False

    def check_silence_expiration(self, chatID):
        """NOUVEAU: V√©rifie si le mode silence a expir√© (2h)"""
        if chatID not in self.user_sessions:
            return False
            
        silence_timestamp = self.get_user_data(chatID, "silence_timestamp", None)
        if silence_timestamp:
            current_time = time.time()
            # 2 heures = 7200 secondes
            if current_time - silence_timestamp > 7200:
                print(f"‚è∞ Mode silence expir√© pour {chatID} apr√®s 2h")
                # R√©initialiser l'utilisateur
                self.set_user_state(chatID, "menu")
                self.set_user_data(chatID, "silence_timestamp", None)
                self.set_user_data(chatID, "menu_warnings", 0)
                return True
        return False

    def activate_silence_mode(self, chatID, reason="non_cooperative"):
        """NOUVEAU: Active le mode silence pour un utilisateur"""
        self.set_user_state(chatID, "silence_mode")
        self.set_user_data(chatID, "silence_timestamp", time.time())
        self.set_user_data(chatID, "silence_reason", reason)
        print(f"üîá Mode silence activ√© pour {chatID} - Raison: {reason}")

    def get_main_menu(self):
        return """Bienvenue chez irabonnement.com üëã

Je suis l'assistant automatique con√ßu par DakarDev ü§ñ

Je suis encore en phase d'apprentissage, merci de votre compr√©hension üôè

Voici ce que je peux faire pour vous üëá :

1Ô∏è‚É£ Comment √ßa fonctionne ?
2Ô∏è‚É£ J'ai pass√© commande, je n'ai rien re√ßu
3Ô∏è‚É£ J'ai un probl√®me avec mon compte
4Ô∏è‚É£ Je veux me r√©abonner
5Ô∏è‚É£ Je veux acheter un abonnement
6Ô∏è‚É£ Contacter un conseiller humain"""

    def get_services_selection(self):
        return """Parfait üòä

Quel produit souhaitez-vous comprendre ? R√©pondez simplement avec le nom du produit parmi cette liste :

- Netflix
- Prime Video
- Disney+
- Crunchyroll
- IPTV
- Surfshark VPN
- NordVPN
- Carte Xbox
- Carte PSN
- HBO Max"""

    def get_service_info(self, service):
        """Reconnaissance des noms de services"""
        service_lower = service.lower().strip()
        
        service_info = {
            "netflix": "üü• Netflix :\n\nüé¨ Netflix : √Ä partir de 2500F, vous cotisez pour un profil personnel, utilisable sur un seul appareil.\n\nUne fois votre commande pass√©e, vous recevez automatiquement vos acc√®s par mail et WhatsApp.",
            "prime video": "üü¶ Prime Video :\n\nüé• Prime Video : Service de streaming Amazon avec films et s√©ries exclusives.\n\nAcc√®s direct apr√®s commande, compatible tous appareils.",
            "prime": "üü¶ Prime Video :\n\nüé• Prime Video : Service de streaming Amazon avec films et s√©ries exclusives.\n\nAcc√®s direct apr√®s commande, compatible tous appareils.",
            "disney+": "üü¶ Disney+ :\n\nüé• Disney+ : Disponible uniquement via VPN.\n\nNous vous fournissons un compte Disney+ + un compte VPN.\n\n1Ô∏è‚É£ Connectez d'abord le VPN aux üá∫üá∏ USA (serveur Chicago)\n2Ô∏è‚É£ Ensuite, ouvrez l'application Disney+",
            "disney": "üü¶ Disney+ :\n\nüé• Disney+ : Disponible uniquement via VPN.\n\nNous vous fournissons un compte Disney+ + un compte VPN.\n\n1Ô∏è‚É£ Connectez d'abord le VPN aux üá∫üá∏ USA (serveur Chicago)\n2Ô∏è‚É£ Ensuite, ouvrez l'application Disney+",
            "crunchyroll": "üü† Crunchyroll :\n\nüéå Crunchyroll : La plateforme #1 pour les anim√©s et mangas.\n\nAcc√®s premium √† tous les contenus, sous-titres fran√ßais disponibles.",
            "iptv": "üü© IPTV :\n\nüì∫ IPTV : N√©cessite un VPN ou une configuration DNS.\n\nVoici les √©tapes :\n1Ô∏è‚É£ T√©l√©chargez une app OTT (ex : Smarters Player, Televizo, 9Xtream, Hot IPTV)\n2Ô∏è‚É£ Connectez un VPN (comme Surfshark) ou utilisez les DNS fournis apr√®s l'achat.",
            "surfshark vpn": "üîí Surfshark VPN :\n\nüõ°Ô∏è VPN premium pour s√©curiser votre connexion et acc√©der aux contenus g√©o-bloqu√©s.\n\nCompatible tous appareils, configuration simple.",
            "surfshark": "üîí Surfshark VPN :\n\nüõ°Ô∏è VPN premium pour s√©curiser votre connexion et acc√©der aux contenus g√©o-bloqu√©s.\n\nCompatible tous appareils, configuration simple.",
            "nordvpn": "üîµ NordVPN :\n\nüõ°Ô∏è VPN haut de gamme pour protection et acc√®s mondial.\n\nServeurs ultra-rapides, s√©curit√© maximale.",
            "nord vpn": "üîµ NordVPN :\n\nüõ°Ô∏è VPN haut de gamme pour protection et acc√®s mondial.\n\nServeurs ultra-rapides, s√©curit√© maximale.",
            "nord": "üîµ NordVPN :\n\nüõ°Ô∏è VPN haut de gamme pour protection et acc√®s mondial.\n\nServeurs ultra-rapides, s√©curit√© maximale.",
            "carte xbox": "üü¢ Carte Xbox :\n\nüéÆ Cartes cadeaux Xbox pour acheter jeux et contenus.\n\nLivraison imm√©diate du code de la carte.",
            "xbox": "üü¢ Carte Xbox :\n\nüéÆ Cartes cadeaux Xbox pour acheter jeux et contenus.\n\nLivraison imm√©diate du code de la carte.",
            "carte psn": "üîµ Carte PSN :\n\nüéÆ Cartes PlayStation Network pour le PlayStation Store.\n\nCodes livr√©s instantan√©ment apr√®s achat.",
            "psn": "üîµ Carte PSN :\n\nüéÆ Cartes PlayStation Network pour le PlayStation Store.\n\nCodes livr√©s instantan√©ment apr√®s achat.",
            "hbo max": "üü£ HBO Max :\n\nüé≠ HBO Max : S√©ries et films premium, contenu exclusif.\n\nAcc√®s complet √† la biblioth√®que HBO.",
            "hbo": "üü£ HBO Max :\n\nüé≠ HBO Max : S√©ries et films premium, contenu exclusif.\n\nAcc√®s complet √† la biblioth√®que HBO."
        }
        
        if service_lower in service_info:
            return service_info[service_lower]
        
        for key, value in service_info.items():
            if service_lower in key or key in service_lower:
                return value
        
        return "‚ùå Service non trouv√©. Veuillez taper exactement un nom de la liste."

    def handle_email_verification_request(self, chatID):
        """NOUVEAU: Demande de v√©rification email avant option 2"""
        return """Avant tout, veuillez v√©rifier votre bo√Æte mail et le num√©ro WhatsApp que vous avez fourni lors de l'abonnement.

Les informations de connexion sont automatiquement envoy√©es √† ces deux endroits.

Si vous ne trouvez rien, revenez ici et r√©pondez :

1Ô∏è‚É£ J'ai trouv√©, merci
2Ô∏è‚É£ Je n'ai rien trouv√©"""

    def handle_technical_problem(self, chatID):
        return """D√©sol√© pour le d√©sagr√©ment üò•

Pour mieux comprendre votre probl√®me, merci de nous envoyer une **capture d'√©cran** du message ou de l'erreur rencontr√©e.

Une fois re√ßu, nous le transmettrons au service technique."""

    def handle_bug_solutions(self, chatID):
        return """D√©sol√© pour cela üò•

Voici quelques v√©rifications de base :

1Ô∏è‚É£ D√©sinstallez puis r√©installez l'application
2Ô∏è‚É£ Red√©marrez votre appareil  
3Ô∏è‚É£ Assurez-vous d'avoir activ√© le VPN si n√©cessaire

üëâ Si cela ne fonctionne toujours pas, merci de nous envoyer une **capture d'√©cran** de l'erreur.

Nous transmettrons √† notre service technique."""

    def handle_resubscription(self, chatID):
        return """Merci de vous rendre sur notre site : https://irabonnement.com

üëâ Si votre abonnement est expir√©, vous devrez commander un **nouveau compte**."""

    def handle_new_purchase(self, chatID):
        return """Parfait ‚úÖ

Vous pouvez commander directement sur : https://irabonnement.com

La livraison est automatique üì©"""

    def handle_human_advisor(self, chatID):
        """MODIFI√â: Apr√®s alerte SAV, passage en silence total"""
        self.send_to_sav({"phone": chatID}, "conseiller_humain")
        
        # NOUVEAU: Activer le silence total apr√®s alerte SAV
        self.activate_silence_mode(chatID, "waiting_human_sav")
        
        return """Votre demande a √©t√© transmise √† notre service client.

‚è≥ Un conseiller va vous r√©pondre dans un d√©lai estim√© de **moins de 40 minutes** (entre 10h et 22h).

Merci pour votre patience."""

    def is_in_active_flow(self, chatID):
        """V√©rifie si l'utilisateur est dans un flux actif"""
        state = self.get_user_state(chatID)
        active_states = ["waiting_name", "waiting_payment_screenshot", "waiting_screenshot", "services_selection", "verification_email"]
        return state in active_states

    def check_spam(self, chatID):
        """Spam check intelligent"""
        current_time = time.time()
        
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"messages": [], "state": "menu", "data": {}}
        
        current_state = self.get_user_state(chatID)
        
        # Si utilisateur dans un flux actif, PAS de spam check
        if self.is_in_active_flow(chatID):
            print(f"üîÑ Utilisateur {chatID} dans flux actif - pas de spam check")
            return False
        
        # Ajouter le message actuel
        self.user_sessions[chatID]["messages"].append(current_time)
        
        # Si utilisateur transf√©r√© : spam apr√®s 3+ messages en 2 minutes
        if current_state in ["transferred_to_sav", "transferred_to_human"]:
            self.user_sessions[chatID]["messages"] = [
                msg_time for msg_time in self.user_sessions[chatID]["messages"] 
                if current_time - msg_time < 120
            ]
            
            message_count = len(self.user_sessions[chatID]["messages"])
            print(f"üîç Spam check transf√©r√© - Messages: {message_count}")
            
            self.save_sessions()
            
            if message_count >= 6:
                return "transferred_total_silence"
            elif message_count >= 3:
                return "transferred_spam"
            else:
                return "transferred_silent"
        
        # Utilisateur normal : spam = 3+ messages en 90 secondes
        else:
            self.user_sessions[chatID]["messages"] = [
                msg_time for msg_time in self.user_sessions[chatID]["messages"] 
                if current_time - msg_time < 90
            ]
            
            message_count = len(self.user_sessions[chatID]["messages"])
            print(f"üîç Spam check normal - Messages: {message_count}")
            
            self.save_sessions()
            
            if message_count >= 3:
                return "normal_spam"
        
        return False

    def get_user_state(self, chatID):
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"state": "menu", "messages": [], "data": {}}
        return self.user_sessions[chatID]["state"]

    def set_user_state(self, chatID, state):
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"messages": [], "data": {}}
        self.user_sessions[chatID]["state"] = state
        print(f"üîÑ √âtat chang√© pour {chatID}: {state}")
        self.save_sessions()

    def get_user_data(self, chatID, key, default=None):
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"state": "menu", "messages": [], "data": {}}
        return self.user_sessions[chatID]["data"].get(key, default)

    def set_user_data(self, chatID, key, value):
        if chatID not in self.user_sessions:
            self.user_sessions[chatID] = {"state": "menu", "messages": [], "data": {}}
        self.user_sessions[chatID]["data"][key] = value
        self.save_sessions()

    def is_image_message(self, message):
        """D√©tecte si le message est une image"""
        return message.get('type') == 'image'

    def is_valid_menu_response(self, message_lower):
        """CORRIG√â: V√©rifie si la r√©ponse est valide pour le menu (SANS salutations)"""
        # R√©ponses valides du menu
        valid_responses = [
            "1", "2", "3", "4", "5", "6",
            "comment √ßa fonctionne", "j'ai pass√© commande", "rien re√ßu",
            "probl√®me avec mon compte", "r√©abonner", "reabonner", 
            "acheter un abonnement", "nouvelle commande", 
            "conseiller humain", "agent"
        ]
        
        # V√©rifier r√©ponses exactes du menu
        if message_lower in valid_responses:
            return True
            
        # V√©rifier phrases contenues
        for response in valid_responses:
            if response in message_lower:
                return True
                
        return False

    def is_salutation(self, message_lower):
        """NOUVEAU: V√©rifie si c'est une salutation"""
        salutations = [
            "salut", "hey", "yo", "bonjour", "bonsoir", "hello", "hi",
            "coucou", "bonne journ√©e", "bonne soir√©e"
        ]
        
        for salutation in salutations:
            if salutation in message_lower:
                return True
        return False

    def handle_menu_warning(self, chatID, message_lower):
        """CORRIG√â: G√®re les avertissements pour r√©ponses hors menu (PAS pour salutations)"""        
        warnings = self.get_user_data(chatID, "menu_warnings", 0)
        
        if warnings == 0:
            # Premier avertissement
            self.set_user_data(chatID, "menu_warnings", 1)
            return self.send_message(chatID, self.menu_warning_messages["first"])
            
        elif warnings == 1:
            # Deuxi√®me avertissement
            self.set_user_data(chatID, "menu_warnings", 2)
            return self.send_message(chatID, self.menu_warning_messages["second"])
            
        else:
            # Troisi√®me fois : mode silence
            self.activate_silence_mode(chatID, "non_cooperative")
            return self.send_message(chatID, self.menu_warning_messages["final"])

    def ProcessingŸÄincomingŸÄmessages(self):
        if self.dict_messages != []:
            message = self.dict_messages
            
            # V√©rification de d√©duplication
            if self.is_message_already_processed(message):
                return 'AlreadyProcessed'
            
            # Marquer le message comme trait√©
            self.mark_message_as_processed(message)
            
            # Ignorer les messages du groupe SAV
            sav_group_id = "120363366576958989@g.us"
            if message.get('from') == sav_group_id:
                print(f"üîá Message du groupe SAV ignor√© - pas de traitement")
                return 'SAVGroupIgnored'
            
            # NOUVEAU: D√©tecter si un SAV humain prend en charge
            if self.check_sav_takeover(message):
                chatID = message.get('to', '')  # Le destinataire du message SAV
                if chatID:
                    print(f"üë®‚Äçüíº SAV humain d√©tect√© pour {chatID} - activation silence total")
                    self.activate_silence_mode(chatID, "human_sav_active")
                return 'HumanSAVDetected'
            
            # Traitement des images et messages
            if self.is_image_message(message):
                print(f"üì∏ Image re√ßue de {message['from']}")
                chatID = message['from']
                message_body = "[IMAGE]"
                message_lower = "image"
            elif not message.get('body'):
                print("Message vide re√ßu (pas une image)")
                return 'EmptyMessage'
            else:
                chatID = message['from']
                message_body = message['body'].strip()
                message_lower = message_body.lower()
            
            # Ignorer nos propres messages
            if message['fromMe']:
                print("Message envoy√© par nous, ignor√©")
                return 'FromMe'
                
            print(f"üì± Message re√ßu de {chatID}: {message_body}")
            print(f"üîÑ √âtat actuel: {self.get_user_state(chatID)}")
            
            # NOUVEAU: V√©rifier expiration du silence (2h)
            if self.check_silence_expiration(chatID):
                # Utilisateur r√©activ√©, traiter le message normalement
                pass
            
            # V√©rifier si en mode silence
            current_state = self.get_user_state(chatID)
            if current_state == "silence_mode":
                print(f"üîá Utilisateur {chatID} en mode silence - aucune r√©ponse")
                return "SilenceMode"
            
            # PRIORIT√â #1 : Commande "menu" (r√©active toujours)
            if message_lower in ['menu', 'accueil', 'retour', 'retourner au menu']:
                print(f"üîÑ RETOUR AU MENU FORC√â")
                self.set_user_state(chatID, "menu")
                self.set_user_data(chatID, "menu_warnings", 0)  # Reset warnings
                self.set_user_data(chatID, "silence_timestamp", None)  # Reset silence
                if chatID in self.user_sessions:
                    self.user_sessions[chatID]["messages"] = []
                return self.send_message(chatID, self.get_main_menu())
            
            # PRIORIT√â #2 : Gestion du spam
            spam_status = self.check_spam(chatID)
            
            if spam_status == "transferred_total_silence":
                print(f"üîá Utilisateur {chatID} transf√©r√© - silence total")
                return "TransferredTotalSilence"
                
            elif spam_status == "transferred_spam":
                response = random.choice(self.transferred_spam_messages)
                print(f"‚ö†Ô∏è Utilisateur {chatID} transf√©r√© - message anti-spam")
                return self.send_message(chatID, response)
                
            elif spam_status == "transferred_silent":
                print(f"üîá Utilisateur {chatID} transf√©r√© - silence simple")
                return "TransferredSilent"
                
            elif spam_status == "normal_spam":
                spam_response = random.choice(self.anti_spam_messages)
                print(f"‚ö†Ô∏è Utilisateur {chatID} normal - anti-spam")
                return self.send_message(chatID, spam_response)
            
            # PRIORIT√â #3 : Salutations (seulement si √©tat menu)
            if current_state == "menu":
                if any(word in message_lower for word in ['bonjour', 'bonsoir', 'salut', 'hello', 'hi']):
                    print(f"üëã Salutation d√©tect√©e: {message_lower}")
                    return self.send_message(chatID, self.get_main_menu())
                
                if "je vous contacte depuis le site irabonnement" in message_lower:
                    print(f"üåê Message site d√©tect√©")
                    return self.send_message(chatID, self.get_main_menu())
                    
                if "j'ai une question" in message_lower:
                    print(f"‚ùì Question g√©n√©rique d√©tect√©e")
                    return self.send_message(chatID, self.get_main_menu())
            
            # PRIORIT√â #4 : Politesse (sauf si transf√©r√©)
            if current_state not in ["transferred_to_sav", "transferred_to_human", "silence_mode"]:
                if message_lower in ['merci', 'thank you', 'thanks']:
                    return self.send_message(chatID, "Je vous en prie üòä")
            
            # PRIORIT√â #5 : Gestion des bugs (sauf si transf√©r√©)
            if current_state not in ["transferred_to_sav", "transferred_to_human", "silence_mode"]:
                if any(word in message_lower for word in ['√ßa marche pas', 'marche pas', 'bug', 'ne fonctionne pas', 'probl√®me connexion', 'je n\'arrive pas', 'pas connecter']):
                    self.set_user_state(chatID, "menu")
                    return self.send_message(chatID, self.handle_bug_solutions(chatID))
            
            # === NAVIGATION SELON L'√âTAT ===
            if current_state == "menu":
                print(f"üè† Traitement menu pour: {message_lower}")
                
                # Gestion des images non sollicit√©es
                if message_lower == "image":
                    return self.send_message(chatID, "Je n'ai pas besoin d'image pour le moment. üòä\n\nVeuillez choisir une option du menu en tapant le num√©ro (1, 2, 3, 4, 5 ou 6).")
                
                # Messages sp√©cifiques du site (toujours valides)
                if "je vous contacte depuis le site irabonnement" in message_lower:
                    print(f"üåê Message site d√©tect√©")
                    return self.send_message(chatID, self.get_main_menu())
                    
                if "j'ai une question" in message_lower:
                    print(f"‚ùì Question g√©n√©rique d√©tect√©e")
                    return self.send_message(chatID, self.get_main_menu())
                
                # PRIORIT√â: Si c'est une salutation, r√©afficher le menu (PAS d'avertissement)
                if self.is_salutation(message_lower):
                    print(f"üëã Salutation d√©tect√©e en √©tat menu: {message_lower}")
                    return self.send_message(chatID, self.get_main_menu())
                
                # V√©rifier si r√©ponse valide au menu
                if not self.is_valid_menu_response(message_lower):
                    print(f"‚ùå R√©ponse hors menu d√©tect√©e (pas une salutation)")
                    return self.handle_menu_warning(chatID, message_lower)
                
                # Reset des warnings si r√©ponse valide du menu
                self.set_user_data(chatID, "menu_warnings", 0)
                
                if message_lower == "1" or "comment √ßa fonctionne" in message_lower:
                    self.set_user_state(chatID, "services_selection")
                    return self.send_message(chatID, self.get_services_selection())
                    
                elif message_lower == "2" or "j'ai pass√© commande" in message_lower or "rien re√ßu" in message_lower:
                    # NOUVEAU: Demander v√©rification email d'abord
                    self.set_user_state(chatID, "verification_email")
                    return self.send_message(chatID, self.handle_email_verification_request(chatID))
                    
                elif message_lower == "3" or "probl√®me avec mon compte" in message_lower:
                    self.set_user_state(chatID, "waiting_screenshot")
                    return self.send_message(chatID, self.handle_technical_problem(chatID))
                    
                elif message_lower == "4" or "r√©abonner" in message_lower or "reabonner" in message_lower:
                    return self.send_message(chatID, self.handle_resubscription(chatID))
                    
                elif message_lower == "5" or "acheter un abonnement" in message_lower or "nouvelle commande" in message_lower:
                    return self.send_message(chatID, self.handle_new_purchase(chatID))
                    
                elif message_lower == "6" or "conseiller humain" in message_lower or "agent" in message_lower:
                    return self.send_message(chatID, self.handle_human_advisor(chatID))
                    
            elif current_state == "verification_email":
                # NOUVEAU: Gestion de la v√©rification email
                if message_lower == "1" or "j'ai trouv√©" in message_lower or "j'ai vu" in message_lower:
                    self.set_user_state(chatID, "menu")
                    return self.send_message(chatID, "Je vous en prie üòä\n\nTapez 'menu' si vous avez besoin d'autre chose.")
                    
                elif message_lower == "2" or "je n'ai rien trouv√©" in message_lower or "j'ai pas" in message_lower:
                    # Passer √† la proc√©dure normale (nom + capture)
                    self.set_user_state(chatID, "waiting_name")
                    return self.send_message(chatID, """D'accord, nous allons vous aider ‚úÖ

Veuillez d'abord nous envoyer votre **nom et pr√©nom** utilis√©s lors de la commande.

Ensuite, nous vous demanderons la capture d'√©cran de votre paiement.""")
                else:
                    return self.send_message(chatID, "Veuillez r√©pondre par :\n\n1Ô∏è‚É£ J'ai trouv√©, merci\n2Ô∏è‚É£ Je n'ai rien trouv√©")
                    
            elif current_state == "services_selection":
                print(f"üéØ Recherche service pour: '{message_lower}'")
                service_info = self.get_service_info(message_lower)
                
                if "‚ùå Service non trouv√©" not in service_info:
                    print(f"‚úÖ Service trouv√©, envoi info")
                    self.set_user_state(chatID, "menu")
                    return self.send_message(chatID, service_info + "\n\nTapez 'menu' pour retourner au menu principal.")
                else:
                    print(f"‚ùå Service non trouv√©")
                    return self.send_message(chatID, "‚ùå Service non trouv√©. " + self.get_services_selection())
                
            elif current_state == "waiting_name":
                if message_lower == "image":
                    return self.send_message(chatID, "Merci pour l'image, mais nous avons d'abord besoin de votre **nom et pr√©nom** en texte.")
                
                print(f"üë§ Nom re√ßu: {message_body}")
                self.set_user_data(chatID, "customer_name", message_body)
                self.set_user_state(chatID, "waiting_payment_screenshot")
                
                return self.send_message(chatID, f"""Merci {message_body} ‚úÖ

Maintenant, veuillez envoyer la **capture d'√©cran de votre paiement**.

D√®s r√©ception, nous transmettrons le tout au service technique.""")
                
            elif current_state == "waiting_payment_screenshot":
                if message_lower != "image":
                    return self.send_message(chatID, "Nous attendons la **capture d'√©cran de votre paiement**. Veuillez envoyer l'image.")
                
                print(f"üí≥ Capture paiement re√ßue de: {chatID}")
                customer_name = self.get_user_data(chatID, "customer_name", "Non fourni")
                
                # Envoyer au SAV
                self.send_to_sav({
                    "phone": chatID,
                    "name": customer_name,
                    "payment_proof": "Capture de paiement re√ßue",
                    "type": "no_access"
                }, "no_access")
                
                self.set_user_state(chatID, "transferred_to_sav")
                response = f"""‚úÖ Parfait ! Nous avons bien re√ßu vos informations :

üë§ Nom : {customer_name}
üí≥ Capture de paiement : Re√ßue

üì§ Votre dossier a √©t√© transmis √† notre service technique.

‚è≥ Un agent va vous r√©pondre dans un d√©lai estim√© de moins de 40 minutes (entre 10h et 22h).

Merci pour votre patience."""
                return self.send_message(chatID, response)
                
            elif current_state == "waiting_screenshot":
                if message_lower != "image":
                    return self.send_message(chatID, "Nous attendons une **capture d'√©cran** de votre probl√®me. Veuillez envoyer l'image.")
                
                print(f"üì∏ Capture technique re√ßue de: {chatID}")
                
                self.send_to_sav({
                    "phone": chatID,
                    "problem": "Capture d'√©cran du probl√®me re√ßue",
                    "type": "technical"
                }, "technical")
                
                self.set_user_state(chatID, "transferred_to_sav")
                response = """‚úÖ Merci ! Nous avons bien re√ßu votre capture d'√©cran.

üì§ Votre probl√®me a √©t√© transmis √† notre service technique.

‚è≥ Un agent vous r√©pondra sous peu (d√©lai moyen : moins de 40 minutes, entre 10h et 22h).

Nous allons r√©gler votre probl√®me rapidement."""
                return self.send_message(chatID, response)
                
            elif current_state in ["transferred_to_sav", "transferred_to_human"]:
                print(f"üîá Utilisateur {chatID} transf√©r√© - trait√© par la gestion du spam")
                return "TransferredHandledBySpam"
            
            # Message non reconnu (sauf si transf√©r√© ou en silence)
            if current_state not in ["transferred_to_sav", "transferred_to_human", "silence_mode"]:
                print(f"‚ùì Message non reconnu, retour au menu")
                self.set_user_state(chatID, "menu")
                return self.send_message(chatID, self.get_main_menu())
            
            return "TransferredSilent"
        
        return 'NoData'